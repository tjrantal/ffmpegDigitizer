/*
Copyright (C) 2013  Timo Rantalainen (tjrantal at gmail dot com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

For a copy of the GNU General Public License, see <http://www.gnu.org/licenses/>.
*/
#ifndef VIDEOREADER_H
	#include "VideoReader.h"
#endif
//int64_t av_frame_get_best_effort_timestamp	(	const AVFrame * 	frame	)	

//Constructor
VideoReader::VideoReader(const char* file)
{
	videoOpen = false;
	av_register_all();	//Register formats
	filename = file;		//File to open
	
	// Open video file
	pFormatCtx = NULL;
	//printf("%s\n",filename);
	fflush(stdout);			//DEBUGGING
	if(avformat_open_input(&pFormatCtx, filename, NULL, NULL)!=0){
		//printf("Couldn't open file\n");
		fflush(stdout);			//DEBUGGING
		return;
	}

	if(avformat_find_stream_info(pFormatCtx,NULL)<0){
		//printf("Coudln't find stream\n");
		fflush(stdout);			//DEBUGGING
		return;
	}

	av_dump_format(pFormatCtx, 0, filename, 0);
	//Print additional debugging...
	//printf("Start time %ld\n",pFormatCtx->start_time);
	//printf("Duration %ld\n",pFormatCtx->duration);
	
	fflush(stdout);			//DEBUGGING
			// Find the first video stream
	  /* retrieve stream information */
	  /*
	videoStream=-1;
	for(unsigned int i=0; i<pFormatCtx->nb_streams; i++){
		if(pFormatCtx->streams[i]->codec->codec_type==AVMEDIA_TYPE_VIDEO)
		{
		videoStream=i;
		break;
		}
	}
	if(videoStream==-1){
		//printf("no videostream\n");
		fflush(stdout);			//DEBUGGING
		return;
	}
	*/
	videoStream = av_find_best_stream(pFormatCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
	//Look for videostream index and open codec context
	if (videoStream < 0) {
	    //printf("Could not videoStreamIndex\n");
		fflush(stdout);			//DEBUGGING
        return;
	}	
	// Get a pointer to the codec context for the video stream
	pCodecCtx=pFormatCtx->streams[videoStream]->codec;
	//Print additional debugging...
	////printf("Delay %d\n",pCodecCtx->delay);
	////printf("timecode_frame_start %ld\n",pCodecCtx->timecode_frame_start);
	////printf("codec frame rate %f\n",((double) pCodecCtx->framerate.num)/((double) pCodecCtx->framerate.den));
	//printf("codec frame rate %d\n",pCodecCtx->seek_preroll);
	
	////printf("time base %f\n",((double) pFormatCtx->streams[videoStream]->time_base.num)/((double) pFormatCtx->streams[videoStream]->time_base.den));
	////printf("nb_frames %ld\n",pFormatCtx->streams[videoStream]->nb_frames);
	
	
	width = pCodecCtx->width;
	height = pCodecCtx->height;

	// Find the decoder for the video stream
	pCodec=avcodec_find_decoder(pCodecCtx->codec_id);
	if(pCodec==NULL){
		//printf("No suitable codec\n");
		return;
		}
	// Open codec
	if(avcodec_open2(pCodecCtx, pCodec,NULL)<0){
		//printf("Couldn't open codec\n");
		return;
		}
		// Hack to correct wrong frame rates that seem to be generated by some codecs
	if(pCodecCtx->time_base.num>1000 && pCodecCtx->time_base.den==1)
		pCodecCtx->time_base.den=1000;
	
	tmp_picture=av_frame_alloc();
	if (!tmp_picture){
		//printf("Coulnd't alloc frame\n");
		fflush(stdout);			//DEBUGGING
		return;
	}

	img_convert_ctx = NULL;
	/*PIX_FMT_YUV420P*/
	if (pCodecCtx->pix_fmt != AV_PIX_FMT_RGB24) {
		//printf("different pix_fmt\n");
	
		picture = av_frame_alloc();
		if (!picture){
			//printf("Couldn't alloc frame\n");
			return;
		}

		int ret = av_image_alloc(picture->data, picture->linesize,
						 pCodecCtx->width, pCodecCtx->height,
						 AV_PIX_FMT_RGB24, 1);
		if (ret < 0) {
			//printf("Could not allocate raw video buffer\n");
			return;
		}
		
		/* as ffmpeg returns a YUV420P picture from a video, we must convert it
		   to the desired pixel format */
		if (img_convert_ctx == NULL) {
			/*Target image format AV_PIX_FMT_RGB24*/
			img_convert_ctx = sws_getContext(pCodecCtx->width, pCodecCtx->height,
											 pCodecCtx->pix_fmt,
											 width, height,
											 AV_PIX_FMT_RGB24
											 , SWS_BICUBIC, NULL, NULL, NULL);
			if (img_convert_ctx == NULL) {
				//printf("Cannot initialize the conversion context\n");
				return;
			}
		}
	}
	
	av_init_packet(&packet);
	packet.data = NULL;
	packet.size = 0;
	videoOpen = true;
	//Reserve memory for a frame
	decodedFrame = new unsigned char [width*height*3*sizeof(unsigned char)];
	//Read one frame & rewind the stream to keep frames consistent...
	//for (int i = 0;i<5;++i){
	//	readNextFrameFromDisk();
	//}
	//av_seek_frame(pFormatCtx,videoStream,(int64_t) 0,AVSEEK_FLAG_BACKWARD);
	lastFrame = -1;
}

/*Read all of the packets to memory, might need to check whether the video is small enough to fit into memory..*/
int VideoReader::readIndices(){
	int frameFinished;
	frameIndices = std::vector<FrameIndice*>();
	lastFrame = -1;		/*Set last frame to -1, since none have been decoded*/
	int frameNo = -1;
	////printf("Read packets from the video\n");	
	while(av_read_frame(pFormatCtx, &packet)>=0) /*Read all frames to memory*/
	{
		
		
	    if(packet.stream_index==videoStream)		 // Is this a packet from the video stream?
	    {	
			////printf("packet dts %ld pts %ld\n",packet.dts,packet.pts);
			avcodec_decode_video2(pCodecCtx, tmp_picture, &frameFinished, 
	            &packet);
	        if (frameFinished){
				++frameNo;
				////printf("FRAME %d dts %ld pts %ld av %ld\n",frameNo,packet.dts,packet.pts,tmp_picture->pkt_dts);
				//int64_t bestPTS = av_frame_get_best_effort_timestamp(tmp_picture);
				////printf("FRAME %d dts %ld pts %ld av_dts %ld av_pts %ld dpn %d best pts %ld\n",frameNo,packet.dts,packet.pts,tmp_picture->pkt_dts,tmp_picture->pkt_pts,tmp_picture->display_picture_number, av_frame_get_best_effort_timestamp(tmp_picture));
				FrameIndice *lastIndice = new FrameIndice(frameNo,tmp_picture->pts,tmp_picture->pkt_pts,tmp_picture->pkt_dts,av_frame_get_best_effort_timestamp(tmp_picture));
				frameIndices.push_back(lastIndice);
				av_packet_unref(&packet);
			}
	    }else{
			av_packet_unref(&packet);
	    }
	}
	/*Check whether null frames need to be fed in to get the remaining data*/
	while (1){
		//Set data to null, if all of the packet has been consumed
		if (packet.size = 0){
			packet.data = NULL;
			packet.size = 0;
		}
		if (avcodec_decode_video2(pCodecCtx, tmp_picture, &frameFinished, 
	            &packet) >=0){
		
			if (frameFinished){
				++frameNo;
				//int64_t bestPTS = av_frame_get_best_effort_timestamp	(tmp_picture);
				
				////printf("REMAIN FRAME %d dts %ld pts %ld av %ld av pts %ld bestPTS %ld\n",frameNo,packet.dts,packet.pts,tmp_picture->pkt_dts,tmp_picture->pkt_pts,bestPTS);
				
				FrameIndice* lastIndice = new FrameIndice(frameNo,tmp_picture->pts,tmp_picture->pkt_pts,tmp_picture->pkt_dts,av_frame_get_best_effort_timestamp(tmp_picture));
				frameIndices.push_back(lastIndice);
				av_packet_unref(&packet);
			}else{
				//printf("Didn't get a frame anymore %d\n",frameNo);
				fflush(stdout);
				break;				
			}
			
		}else{
			break;
		}
	}
	/*Rewind the file*/
	//av_seek_frame(pFormatCtx,videoStream,frameIndices.at(0)->pts,AVSEEK_FLAG_BACKWARD); 
	av_seek_frame(pFormatCtx,videoStream,frameIndices.at(0)->dts,AVSEEK_FLAG_BACKWARD); 
	lastFrame = -1;
	return frameNo;

}


int VideoReader::readNextFrameFromDisk(){
	int frameFinished = 0;
	int readMore = 1;
	////printf("Read nextFrame %d\n", lastFrame);
	while(readMore ==1 && frameFinished==0) //C(pFormatCtx, &packet)>=0
	{
		int readReturn = av_read_frame(pFormatCtx, &packet);
		//Already at the end of file
		if (readReturn <0){
		 break;
		}
	    if(packet.stream_index==videoStream)		 // Is this a packet from the video stream?
	    {
	        avcodec_decode_video2(pCodecCtx, tmp_picture, &frameFinished, &packet);            // Decode video frame
	        if(frameFinished)	            // Did we get a video frame?
	        {
				//int64_t bestPTS = av_frame_get_best_effort_timestamp	(tmp_picture);
				
				////printf("NEXT FRAME From Disk %d dts %ld pts %ld av_dts %ld av_pts %ld dpn %d bestPTS %ld\n",lastFrame+1,packet.dts,packet.pts,tmp_picture->pkt_dts,tmp_picture->pkt_pts,tmp_picture->display_picture_number, av_frame_get_best_effort_timestamp(tmp_picture));
					
				readMore = 0;
				if(img_convert_ctx == NULL){
					////printf("Don't need to scale %d\n", lastFrame + 1);
					if (tmp_picture->linesize[0] != width*sizeof(unsigned char) * 3){ //Hack for padding
						////printf("%d %d %d memcpy hack\n",width, height, tmp_picture->linesize[0]);
						for (int zzz = 0; zzz < height;zzz++){
							////printf("Memcpy hack %d\r", zzz);
							memcpy(decodedFrame+zzz*width*3,tmp_picture->data[0]+zzz*tmp_picture->linesize[0]*3,width*sizeof(unsigned char)*3);
						}
						////printf("\nMemcpy hack done\n");
					} else {
						////printf("Memcpy frame\n");
						memcpy(decodedFrame,tmp_picture->data[0],width*height*sizeof(unsigned char)*3);
					}
				}else{//If pixel_fmt is not targetFormat
					////printf("Scale NEXT FRAME From Disk %d\n", lastFrame + 1);
					
					sws_scale(img_convert_ctx, tmp_picture->data, tmp_picture->linesize,
	                  0, height, picture->data, picture->linesize);
					////printf("Scaled YES NEXT FRAME From Disk %d\n", lastFrame + 1);
					if (picture->linesize[0] != width && picture->linesize[0] != width*3){//Hack for padding (probably not needed...
						////printf("%d memcpy hack\n",picture->linesize[0]);
						for (int zzz = 0; zzz < height;zzz++){
							memcpy(decodedFrame+zzz*width*3,picture->data[0]+zzz*tmp_picture->linesize[0]*3,width*sizeof(unsigned char)*3);
						}
					} else {
						memcpy(decodedFrame,picture->data[0],width*height*sizeof(unsigned char)*3);
						
					}
					////printf("Data in decodedFrame %d\n", lastFrame + 1);
				}
			}
	    }
	    // Free the packet that was allocated by av_read_frame
		av_packet_unref(&packet);
	}
	////printf("Got nextFrame %d %d\n", lastFrame, readMore);
	/*Feed null frames need to get a delayed frame*/
	if (readMore ==1){
		while (1){
			if (packet.size = 0){
				packet.data = NULL;
				packet.size = 0;
			}
			if (avcodec_decode_video2(pCodecCtx, tmp_picture, &frameFinished, 
					&packet) >=0){
			
				if (frameFinished){
					//int64_t bestPTS = av_frame_get_best_effort_timestamp	(tmp_picture);
				
					////printf("NEXT EXTRA FRAME From Disk %d dts %ld pts %ld av_dts %ld av_pts %ld dpn %d bestPTS %ld\n",lastFrame+1,packet.dts,packet.pts,tmp_picture->pkt_dts,tmp_picture->pkt_pts,tmp_picture->display_picture_number,bestPTS);
				
					if(img_convert_ctx == NULL){
						if (tmp_picture->linesize[0] != width*sizeof(unsigned char) * 3){ //Hack for padding
							for (int zzz = 0; zzz < height;zzz++){
								//printf("Memcpy hack extra %d", zzz);
								memcpy(decodedFrame+zzz*width*3,tmp_picture->data[0]+zzz*tmp_picture->linesize[0]*3,width*sizeof(unsigned char)*3);
							}
						} else {
memcpy(decodedFrame, tmp_picture->data[0], width*height*sizeof(unsigned char) * 3);
						}
					}
else {//If pixel_fmt is not targetFormat
	sws_scale(img_convert_ctx, tmp_picture->data, tmp_picture->linesize,
		0, height, picture->data, picture->linesize);

	if (picture->linesize[0] != width && picture->linesize[0] != width * 3) {//Hack for padding (probably not needed...
		////printf("%d memcpy hack\n",picture->linesize[0]);
		for (int zzz = 0; zzz < height; zzz++) {
			memcpy(decodedFrame + zzz*width * 3, picture->data[0] + zzz*tmp_picture->linesize[0] * 3, width*sizeof(unsigned char) * 3);
		}
	}
	else {
		memcpy(decodedFrame, picture->data[0], width*height*sizeof(unsigned char) * 3);

	}
}
break;
				}
else {
	break;
}

			}
else {
	break;
}
		}
	}
	++lastFrame;
	return lastFrame;
}

/** Reads the @param frameNo frame from the file */
int VideoReader::readFrameFromDisk(int frameNo) {
	////printf("Read frame %d %d\n", frameNo, lastFrame);
	/*Do nothing, if requested frame = current frame*/
	if (frameNo == lastFrame) {
		return frameNo;
	}
	/*Read next frame*/
	if (frameNo == lastFrame + 1) {
		readNextFrameFromDisk();
		lastFrame = frameNo;
		return frameNo;
	}
	/*Seek to the desired frame*/
	////printf("Seek %d %d\n", frameNo, lastFrame);
	//int success = av_seek_frame(pFormatCtx,videoStream,frameIndices.at(frameNo)->pkt_pts,AVSEEK_FLAG_BACKWARD);
	int success;
	if (frameNo < 1) {
		success = av_seek_frame(pFormatCtx, videoStream, frameIndices.at(frameNo)->bestPTS, AVSEEK_FLAG_BACKWARD);
	}else{
		success = av_seek_frame(pFormatCtx, videoStream, frameIndices.at(frameNo - 1)->bestPTS, AVSEEK_FLAG_BACKWARD);
	}
	if (success < 0) {
		////printf("Seek failed %d\n", success);
		fflush(stdout);
		return 0;
	}
	bool moreFrames = true;
	int frameFinished;
	int readReturn;
	int decoded = 0;
	av_frame_free(&tmp_picture);
	tmp_picture = av_frame_alloc();
	while (moreFrames) {
		readReturn = av_read_frame(pFormatCtx, &packet);
		//Already at the end of file
		if (readReturn < 0) {
			break;
		}
		if (packet.stream_index == videoStream)
		{
			avcodec_decode_video2(pCodecCtx, tmp_picture, &frameFinished,
				&packet);
			if (frameFinished) {
				++decoded;
				//int64_t bestPTS = av_frame_get_best_effort_timestamp(tmp_picture);
				////printf("Search from Disk %d targe %ld bestPTS %ld\n", frameNo, frameIndices.at(frameNo)->bestPTS, av_frame_get_best_effort_timestamp(tmp_picture));
				//if (packet.pts == frameIndices.at(frameNo)->pkt_pts){
				//if (packet.dts == frameIndices.at(frameNo)->dts){
				//if (tmp_picture->pkt_dts == frameIndices.at(frameNo)->dts){
				if (av_frame_get_best_effort_timestamp(tmp_picture) == frameIndices.at(frameNo)->bestPTS) {
					
					//////printf("FRAME From Disk %d dts %ld pts %ld av_dts %ld av_pts %ld dpn %d\n",frameNo,packet.dts,packet.pts,tmp_picture->pkt_dts,tmp_picture->pkt_pts,tmp_picture->display_picture_number);
					moreFrames = false;
					if (img_convert_ctx == NULL) {
						if (tmp_picture->linesize[0] != width*sizeof(unsigned char) * 3) { //Hack for padding
							for (int zzz = 0; zzz < height; zzz++) {
								memcpy(decodedFrame + zzz*width * 3, tmp_picture->data[0] + zzz*tmp_picture->linesize[0] * 3, width*sizeof(unsigned char) * 3);
							}
						}
						else {
							memcpy(decodedFrame, tmp_picture->data[0], width*height*sizeof(unsigned char) * 3);
						}
					}
					else {//If pixel_fmt is not targetFormat
						sws_scale(img_convert_ctx, tmp_picture->data, tmp_picture->linesize,
							0, height, picture->data, picture->linesize);

						if (picture->linesize[0] != width && picture->linesize[0] != width * 3) {//Hack for padding (probably not needed...
							//////printf("%d memcpy hack\n",picture->linesize[0]);
							for (int zzz = 0; zzz < height; zzz++) {
								memcpy(decodedFrame + zzz*width * 3, picture->data[0] + zzz*tmp_picture->linesize[0] * 3, width*sizeof(unsigned char) * 3);
							}
						}
						else {
							memcpy(decodedFrame, picture->data[0], width*height*sizeof(unsigned char) * 3);

						}
					}
				}
				av_packet_unref( &packet );
				if (av_frame_get_best_effort_timestamp(tmp_picture) > frameIndices.at(frameNo)->bestPTS && decoded > 30) {
					//Try seeking again...
					//printf("reseek!\n");
					decoded = 0;
					if (frameNo > 0) {
						success = av_seek_frame(pFormatCtx, videoStream, frameIndices.at(frameNo-1)->bestPTS, AVSEEK_FLAG_BACKWARD);
					}
					else {
						//printf("Seek failed\n");

						return 0;
					}
					if (success < 0) {
						//printf("Seek failed in re-seek %d\n", success);
						return 0;
					}

				}
			}
				
		}else{
			av_packet_unref( &packet );
		}
	
		
	}
	
	/*Feed null frames need to get a delayed frame*/
	if (moreFrames){
		while (1){
			if (packet.size = 0){
				packet.data = NULL;
				packet.size = 0;
			}
			if (avcodec_decode_video2(pCodecCtx, tmp_picture, &frameFinished, 
					&packet) >=0){
			
				if (frameFinished){
					//if (packet.pts == frameIndices.at(frameNo)->pkt_pts){
					//if (packet.dts == frameIndices.at(frameNo)->dts){
					//int64_t bestPTS = av_frame_get_best_effort_timestamp(tmp_picture);
				
					////printf("Search EXTRA FRAME From Disk %d dts %ld pts %ld av_dts %ld av_pts %ld dpn %d bestPTS %ld\n",frameNo,packet.dts,packet.pts,tmp_picture->pkt_dts,tmp_picture->pkt_pts,tmp_picture->display_picture_number,bestPTS);
					
					if (av_frame_get_best_effort_timestamp(tmp_picture) == frameIndices.at(frameNo)->bestPTS){
					
						if(img_convert_ctx == NULL){
							if (tmp_picture->linesize[0] != width*sizeof(unsigned char) * 3){ //Hack for padding
								for (int zzz = 0; zzz < height;zzz++){
									memcpy(decodedFrame+zzz*width*3,tmp_picture->data[0]+zzz*tmp_picture->linesize[0]*3,width*sizeof(unsigned char)*3);
								}
							} else {
								memcpy(decodedFrame,tmp_picture->data[0],width*height*sizeof(unsigned char)*3);
							}
						}else{//If pixel_fmt is not targetFormat
							sws_scale(img_convert_ctx, tmp_picture->data, tmp_picture->linesize,
							  0, height, picture->data, picture->linesize);
					
							if (picture->linesize[0] != width && picture->linesize[0] != width*3){//Hack for padding (probably not needed...
								////printf("%d memcpy hack\n",picture->linesize[0]);
								for (int zzz = 0; zzz < height;zzz++){
									memcpy(decodedFrame+zzz*width*3,picture->data[0]+zzz*tmp_picture->linesize[0]*3,width*sizeof(unsigned char)*3);
								}
							} else {
								memcpy(decodedFrame,picture->data[0],width*height*sizeof(unsigned char)*3);
								
							}
						}
						break;	/*Got a delayed frame*/
					}

				}else{
					break;	/*Couldn't find a delayed frame*/
				}
				
			}else{
				break;
			}
		}
	}
	
	lastFrame = frameNo;
	return frameNo;
}	

VideoReader::~VideoReader(){
	// Close the video file
	avcodec_close(pCodecCtx);
	avformat_close_input(&pFormatCtx);
	pFormatCtx = NULL;
	pCodecCtx =NULL;
	//Attempt to free and re-alloc picture
	av_frame_free(&tmp_picture);
	tmp_picture = av_frame_alloc();
	

	
	if (img_convert_ctx!= NULL){
		av_freep(&picture->data[0]);
		av_frame_free(&picture);
	}
	//av_free(&picture);
	if (decodedFrame!=NULL){
		delete decodedFrame;
	}
	if (&frameIndices != NULL){
		//Release the objects
		for (int i = 0; i<frameIndices.size();++i){
			delete frameIndices.at(i);
		}
		frameIndices.clear();
	}
}

int VideoReader::getNumberOfFrames(){
	timeBase= (double)pFormatCtx->streams[videoStream]->time_base.num/(double)pFormatCtx->streams[videoStream]->time_base.den;
	duration = ((double) pFormatCtx->streams[videoStream]->duration)*timeBase;
	startTime=(long) pFormatCtx->streams[videoStream]->start_time;
	double frameInterval = (double)pFormatCtx->streams[videoStream]->codec->time_base.num/(double)pFormatCtx->streams[videoStream]->codec->time_base.den;
	////printf("startTime %ld duration %.2f timeBase %.8f frameInterval %.4f\n",startTime,(float) duration,(float) timeBase,(float) frameInterval);
	if (pFormatCtx->streams[videoStream]->nb_frames > 0){
	
		////printf("Stream returned the number of frames %d\n",(int) pFormatCtx->streams[videoStream]->nb_frames);
		return (int) pFormatCtx->streams[videoStream]->nb_frames;
	}
	////printf("Stream DID NOT return the number of frames %d\n",(int) (duration/frameInterval));

	return (int) (duration/timeBase);	/*THIS IS INCORRECT*/
}

int VideoReader::getNumberOfIndices(){
	return (int) frameIndices.size();
}
