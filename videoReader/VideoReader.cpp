/*
Copyright (C) 2013  Timo Rantalainen (tjrantal at gmail dot com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

For a copy of the GNU General Public License, see <http://www.gnu.org/licenses/>.
*/
#ifndef VIDEOREADER_H
	#include "VideoReader.h"
#endif
//Constructor
VideoReader::VideoReader(const char* file, int fram)
{
	av_register_all();	//Rekiströidään formaatit...
	filename = file;		//File to open
	frames = fram;	//Number of frames to be read
	varattu = frames;
	for (int lll = 0;lll<2;++lll){
		tstamp.push_back(0);
	}

	video = new unsigned char*[frames]; //Allocate memory
		
	// Open video file
	pFormatCtx = NULL;
	printf("%s\n",filename);
	if(avformat_open_input(&pFormatCtx, filename, NULL, NULL)!=0){
		printf("Ei saanut filea auki\n");
		exit(1);
	}
				//return -1; // Couldn't open file
	// Retrieve stream information
	if(avformat_find_stream_info(pFormatCtx,NULL)<0){
		printf("Ei loytynyt streamia\n");
		exit(1);
	}
				//return -1; // Couldn't find stream information
   // Dump information about file onto standard error
	av_dump_format(pFormatCtx, 0, filename, 0);
			// Find the first video stream
	videoStream=-1;
	for(unsigned int i=0; i<pFormatCtx->nb_streams; i++)
		if(pFormatCtx->streams[i]->codec->codec_type==AVMEDIA_TYPE_VIDEO)
		{
			videoStream=i;
			break;
		}
	if(videoStream==-1){
		printf("Ei loytynyt videostreamia\n");
		exit(1);
	}
		//return -1; // Didn't find a video stream
	// Get a pointer to the codec context for the video stream
	pCodecCtx=pFormatCtx->streams[videoStream]->codec;
	leveys = pCodecCtx->width;
	korkeus = pCodecCtx->height;
	//printf("Formaatti selvitetty\n");
	// Find the decoder for the video stream
	pCodec=avcodec_find_decoder(pCodecCtx->codec_id);
	if(pCodec==NULL){
		//return -1; // Codec not found
		printf("Ei koodekkia\n");
		}
	// Open codec
	if(avcodec_open2(pCodecCtx, pCodec,NULL)<0){
		//return -1; // Could not open codec
		printf("Koodekki ei auennut\n");
		}
		// Hack to correct wrong frame rates that seem to be generated by some codecs
	if(pCodecCtx->time_base.num>1000 && pCodecCtx->time_base.den==1)
		pCodecCtx->time_base.den=1000;
	// Allocate video frame
	 int size;
	tmp_picture=*(avcodec_alloc_frame());
	if (!&tmp_picture){
		//return 1;
		printf("Ei riittanyt muisti\n");
	}
	size = avpicture_get_size(pCodecCtx->pix_fmt, leveys, korkeus);
	picture_buf2 = (uint8_t*) av_malloc(size);
	if (!picture_buf2) {
		av_free(&tmp_picture);
		//return 1;
		printf("Ei muistia\n");
	}
	avpicture_fill((AVPicture *)&tmp_picture, picture_buf2,
				   pCodecCtx->pix_fmt, leveys, korkeus);


	printf("\n%s%d\n\n","MemSize ",size);
	//Allokoi paketti
	//av_allocpacket

	//Varaa muisti frameille...
	//printf("Varataan muisti\n");
	for (int i = 0;i< frames;i++){
		video[i] =  new unsigned char [leveys*korkeus*3];
		//printf("Varattu %d\r",i);

	}

	img_convert_ctx = NULL;
	/*PIX_FMT_YUV420P*/
	if (pCodecCtx->pix_fmt != PIX_FMT_RGB24) {
		printf("Eri pix_fmt\n");
	
		picture = *(avcodec_alloc_frame());
		if (!&picture){
			//return 1;
			printf("Ei kuvaa\n");
		}
		int size = avpicture_get_size(PIX_FMT_RGB24, leveys, korkeus);
		printf("\n%s%d\n\n","RGB MemSize ",size);
		picture_buf = (uint8_t*) av_malloc(size);
		if (!picture_buf) {
			av_free(&picture);
			//return 1;
			printf("Ei muistia kuvalle\n");
		}
		avpicture_fill((AVPicture *)&picture, picture_buf,
					   PIX_FMT_RGB24, leveys, korkeus);
	
		/* as we only generate a YUV420P picture, we must convert it
		   to the codec pixel format if needed */
		if (img_convert_ctx == NULL) {
			//printf("Korkeus %d Leveys %d\n",pCodecCtx->height,pCodecCtx->width);
			/*Target image format PIX_FMT_YUV420P*/
			img_convert_ctx = sws_getContext(pCodecCtx->width, pCodecCtx->height,
											 pCodecCtx->pix_fmt,
											 leveys, korkeus,
											 PIX_FMT_RGB24
											 , SWS_BICUBIC, NULL, NULL, NULL);
		//printf("Kodek context valittu");
		//sws_getContext (int srcW, int srcH, int srcFormat, int dstW
		//, int dstH, int dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, double *param)
			if (img_convert_ctx == NULL) {
				fprintf(stderr, "Cannot initialize the conversion context\n");
				exit(1);
			}
		}
	}
}


int VideoReader::readFrames(){
	//av_free_packet(&packet);	

	int frameja2 = 0;
	int frameFinished;
	//Seeking (did not work well...) POIS KÄYTÖSTÄ

	//printf("\nfmtTstamp %ld\n",tstamp);

	if (tstamp[0] != 0){ //Have to seek in order to start from the last key frame prior to the time stamp of interest
		printf("\nSeek\n");
		int64_t kohta = tstamp[2];
		printf("Tstamp prior to search %ld\n",tstamp[0]);
		int onnistui = av_seek_frame(pFormatCtx,videoStream,tstamp[2],AVSEEK_FLAG_BACKWARD);
		//printf("Tstamp etsinnan jalkeen %ld fmt %ld\n",packet.pts,*(pFormatCtx->streams[videoStream]).cur_dts);
		if (onnistui < 0){
			printf("Seek failes %d\n",onnistui);
			return 1;
		}
		bool viela = true;
		while (viela){
			av_read_frame( pFormatCtx, &packet );
			if(packet.stream_index==videoStream)
			{
				avcodec_decode_video2(pCodecCtx, &tmp_picture, &frameFinished, 
	            &packet);
				kohta = packet.pts;
				//printf("Tstamp etsinnan aikana %ld\n",kohta);
				if (kohta == tstamp[0]){
					viela = false;
				}
			}
		
			av_free_packet( &packet );
		}
		 printf("Tstamp after seek %ld packet %ld\n",kohta,packet.pts);
		 //Luetaan vielä yksi bonus frame...
	}

	//printf("LukuWhileen\n");
	//cimg_library::CImgDisplay pkuva1(leveys,korkeus,"Pkuva1",0,false,true);

	//pkuva1.move(0,20);
	while(av_read_frame(pFormatCtx, &packet)>=0 && frameja2 < frames )
	{
	    if(packet.stream_index==videoStream)		 // Is this a packet from the video stream?
	    {
			//printf("Dekoodaamaan\n");
	        avcodec_decode_video2(pCodecCtx, &tmp_picture, &frameFinished, &packet);            // Decode video frame
			//printf("Dekoodattiin\n");
	        if(frameFinished)	            // Did we get a video frame?
	        {
				if(img_convert_ctx == NULL){
					//printf("Memcpy, ei skaalausta\n");
					if (tmp_picture.linesize[0] != leveys){ //Hack for padding
						for (int zzz = 0; zzz < korkeus;zzz++){
							memcpy(video[frameja2]+zzz*leveys*3,tmp_picture.data[0]+zzz*tmp_picture.linesize[0]*3,leveys*sizeof(unsigned char)*3);
						}
					} else {
						memcpy(video[frameja2],tmp_picture.data[0],leveys*korkeus*sizeof(unsigned char)*3);
					}
				}else{//If pixel_fmt is not targetFormat
					//printf("Memcpy ja skaalaus\n");
					sws_scale(img_convert_ctx, tmp_picture.data, tmp_picture.linesize,
	                  0, korkeus, picture.data, picture.linesize);
					//printf("Skaalaus onnistui\n");
				
					if (picture.linesize[0] != leveys && picture.linesize[0] != leveys*3){//Hack for padding (probably not needed...
						printf("%d memcpy hack\n",picture.linesize[0]);
						for (int zzz = 0; zzz < korkeus;zzz++){
							memcpy(video[frameja2]+zzz*leveys*3,picture.data[0]+zzz*tmp_picture.linesize[0]*3,leveys*sizeof(unsigned char)*3);
						}
					} else {
						//printf("No hack\n");	
						memcpy(video[frameja2],picture.data[0],leveys*korkeus*sizeof(unsigned char)*3);
					}
					//printf("memcpy onnistui\n");
				}
				/*
				cimg_library::CImg<unsigned char> testi(leveys,korkeus,1,1,0);
				memcpy(testi,video[frameja2],leveys*korkeus*sizeof(unsigned char));
				pkuva1.display(testi);
				pkuva1.wait();
				*/
				frameja2++;
				tstamp.insert(tstamp.begin(),packet.pts);
				printf("tStamp %ld",(long) packet.pts);
				tstamp.pop_back();
			}
	    }
	    // Free the packet that was allocated by av_read_frame
	    av_free_packet(&packet);
	}
	//printf("\nViimeinen %ld %ld\n",packet.pts,tstamp.front());
	frames = frameja2;
	return 1;
}

int VideoReader::closeVideo(){
	
	//printf("Kuvat luettu\n");
	//av_free(&tmp_picture);
	//av_free(&picture);
	// Close the codec
	avcodec_close(pCodecCtx);
// Close the video file
	avformat_close_input(&pFormatCtx);
	//Free memory
	delete [] video;
	video = NULL;
	return 0;
}

int VideoReader::getNumberOfFrames(){
	timeBase= (double)pFormatCtx->streams[videoStream]->time_base.num/(double)pFormatCtx->streams[videoStream]->time_base.den;
	duration = ((double) pFormatCtx->streams[videoStream]->duration)*timeBase;
	startTime=(long) pFormatCtx->streams[videoStream]->start_time;
	double frameInterval = (double)pFormatCtx->streams[videoStream]->codec->time_base.num/(double)pFormatCtx->streams[videoStream]->codec->time_base.den;
	printf("startTime %ld duration %.2f timeBase %.8f frameInterval %.4f\n",startTime,(float) duration,(float) timeBase,(float) frameInterval);
	if (pFormatCtx->streams[videoStream]->nb_frames > 0){
	
		printf("Stream returned the number of frames %d\n",(int) pFormatCtx->streams[videoStream]->nb_frames);
		return (int) pFormatCtx->streams[videoStream]->nb_frames;
	}
	printf("Stream DID NOT return the number of frames %d\n",(int) (duration/frameInterval));

	return (int) (duration/timeBase);
}

